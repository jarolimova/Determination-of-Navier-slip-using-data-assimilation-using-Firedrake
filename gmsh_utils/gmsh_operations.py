import gmsh
import meshio
import os
import math
from typing import List

__all__ = [
    "convert_msh",
    "remeshing",
    "cap_surface",
    "generate_volume_mesh",
    "volume_mesh_from_open_surface",
]


def convert_msh(path: str, new_extension: str = "stl", dim: int = 3):
    """Convert a msh file generated by gmsh to a different file type based on the extension provided.
    The surface is converted using meshio and the conversion is saved to the location of the original file.

    Args:
        path: a complete path to the .msh file
        new_extension: an extension of the file the .msh should be converted to (default: stl)
        dim: in case a 2D mesh is required, dim should be set to 2 (default: 3)
    """
    mesh_io = meshio.read(path)
    base, ext = os.path.splitext(path)
    if dim == 2:
        mesh_io.prune_z_0()
        mesh_io.remove_lower_dimensional_cells()
    mesh_io.write(f"{base}.{new_extension}")
    return


def remeshing(surface_path: str, output_path: str, hmin=None, hmax=None, algorithm2D=1):
    """Remesh an open surface via gmsh
    source code: https://gitlab.onelab.info/gmsh/gmsh/-/blob/master/examples/api/remesh_stl.py

    Mesh generation is based on user-defined arguments hmin, hmax. The best algorithm seems to be MeshAdapt (no. 1)

    Args:
        surface_path : path to the .stl file (open surface)
        output_path : path to a new .stl file (open surface)
        hmin, hmax : characteristic edgelengths are the options for gmsh
        algorithm2D : set algorithm for 2D mesh generation (1: MeshAdapt, 2: Automatic, 3: Initial mesh only, 5: Delaunay, 6: Frontal-Delaunay, 7: BAMG, 8: Frontal-Delaunay for Quads, 9: Packing of Parallelograms)
    """

    # INITIALIZE MESH (and resave in gmsh format)
    gmsh.initialize()
    gmsh.merge(surface_path)  # load mesh

    # # make sure that our mesh does not contain duplicate nodes or triangles
    # # remove duplicate nodes (given a tolerance)
    # gmsh.option.setNumber('Geometry.Tolerance', 1e-4)
    # gmsh.model.mesh.removeDuplicateNodes()
    # gmsh.option.setNumber('Mesh.StlRemoveDuplicateTriangles', 1)

    # set options
    gmsh.option.setNumber(
        "Mesh.Algorithm", algorithm2D
    )  # (1: MeshAdapt, 2: Automatic, 3: Initial mesh only, 5: Delaunay, 6: Frontal-Delaunay, 7: BAMG, 8: Frontal-Delaunay for Quads, 9: Packing of Parallelograms)
    gmsh.option.setNumber("Mesh.MeshSizeMin", hmin)
    gmsh.option.setNumber("Mesh.MeshSizeMax", hmax)

    # classify surface mesh according to given angle, and create discrete model entities (surfaces, curves and points) accordingly
    # see more here: https://gitlab.onelab.info/gmsh/gmsh/blob/gmsh_4_11_1/api/gmsh.py#L4718
    gmsh.model.mesh.classifySurfaces(math.pi, True, True)

    # Create a geometry for all the discrete curves and surfaces in the mesh by computing a parametrization for each one
    gmsh.model.mesh.createGeometry()  # THIS FUNCTION DOES THE REMESHING
    gmsh.model.geo.synchronize()

    # generate and save open surface mesh
    gmsh.model.mesh.generate(3)
    gmsh.write(output_path)

    gmsh.finalize()


def cap_surface(surface_path: str, output_path: str, algorithm2D=1):
    """Cap an OPEN surface mesh via gmsh and save a CLOSED surface
    source code: https://gitlab.onelab.info/gmsh/gmsh/blob/gmsh_4_11_1/examples/api/aneurysm.py

    Args:
        surface_path : path to the .stl file (open surface)
        output_path : path to a new .stl file (closed surface)
        algorithm2D : set algorithm for 2D mesh generation (1: MeshAdapt, 2: Automatic, 3: Initial mesh only, 5: Delaunay, 6: Frontal-Delaunay, 7: BAMG, 8: Frontal-Delaunay for Quads, 9: Packing of Parallelograms)
    """

    # INITIALIZE MESH (and resave in gmsh format)
    gmsh.initialize()
    gmsh.merge(surface_path)  # load mesh
    gmsh.model.mesh.classifySurfaces(math.pi, True, True)
    gmsh.model.geo.synchronize()

    # now we will fill the holes in the surface
    # first, get surface entities and tags
    s_ent = gmsh.model.getEntities(2)  # surface entities
    surf_tags = [s[1] for s in s_ent]

    # second, get boundaries of holes
    bnd_ent = gmsh.model.getBoundary(s_ent)
    curv_tags = [c[1] for c in bnd_ent]

    # finally, create plane surfaces filling the holes
    loops = gmsh.model.geo.addCurveLoops(curv_tags)
    for l in loops:
        surf_tags.append(gmsh.model.geo.addPlaneSurface([l]))

    # set option
    gmsh.option.setNumber(
        "Mesh.Algorithm", algorithm2D
    )  # (1: MeshAdapt, 2: Automatic, 3: Initial mesh only, 5: Delaunay, 6: Frontal-Delaunay, 7: BAMG, 8: Frontal-Delaunay for Quads, 9: Packing of Parallelograms)

    # generate and save a closed surface mesh
    gmsh.model.geo.synchronize()
    gmsh.model.mesh.generate(3)
    gmsh.write(output_path)

    gmsh.finalize()


def generate_volume_mesh(
    surface_path: str,
    output_path: str,
    hmin=None,
    hmax=None,
    extend_field=False,
    dist_max=None,
    algorithm3D=1,
):
    """Generate volume mesh from a CLOSED surface mesh via gmsh

    GMSH can sometimes generate better volume meshes than VMTK.
    Mesh generation is based on either the edgelengths on the surface mesh or specified by arguments hmin, hmax.

    Args:
        surface_path : path to the .stl file (closed surface)
        output_path : path to a new volume mesh; possible extension of the file will be cut and
                    only .vtu and .xml files will be saved (since it must be something that meshio can handle)
        hmin, hmax : characteristic edgelengths are the options for gmsh to generate volume mesh
                    if None, the edgelengths are taken from the surface mesh
        extend_field : (Boolean) if True, volume mesh will be finer near the boundary
                        the element sizes will increase linearly with distance from the boundary
        dist_max : if extend_field=True, we must specify the maximal distance of the field from the boundary
                    the dimension will be the same as our surface mesh
        algorithm3D : set algorithm for 3D mesh generation (1: Delaunay, 3: Initial mesh only, 4: Frontal, 7: MMG3D, 9: R-tree, 10: HXT)
    """

    # INITIALIZE MESH (and resave in gmsh format)
    gmsh.initialize()
    gmsh.merge(surface_path)  # load mesh to meshio

    # SET OPTIONS
    # if no limits are set, edge sizes are extended from the boundary (i.e. uniform mesh)
    if hmax is None and hmin is None and not extend_field:
        gmsh.option.setNumber(
            "Mesh.MeshSizeExtendFromBoundary", 1
        )  # we want to use the same edgelenth as on the boundary
    # if we specify hmin and hmax, we do not use the information from the surface mesh
    # as it would result in the same as above when using "Mesh.Algorithm3D"=1 (Delaunay)
    # (if we had used "Mesh.Algorithm3D"=4, we could extend from boundary)
    elif not extend_field:
        gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
        gmsh.option.setNumber("Mesh.MeshSizeMax", hmax)
        gmsh.option.setNumber("Mesh.MeshSizeMin", hmin)
    else:
        gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
        gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
        gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)
        # new "Extend" field:
        # source code: https://gitlab.onelab.info/gmsh/gmsh/-/blob/gmsh_4_11_1/examples/api/extend_field.py
        f = gmsh.model.mesh.field.add("Extend")
        gmsh.model.mesh.field.setNumbers(
            f, "SurfacesList", [e[1] for e in gmsh.model.getEntities(2)]
        )
        gmsh.model.mesh.field.setNumbers(
            f, "CurvesList", [e[1] for e in gmsh.model.getEntities(1)]
        )
        gmsh.model.mesh.field.setNumber(f, "DistMax", dist_max)
        gmsh.model.mesh.field.setNumber(f, "SizeMax", hmax)
        gmsh.model.mesh.field.setNumber(f, "Power", 1.0)
        gmsh.model.mesh.field.setAsBackgroundMesh(f)

    gmsh.option.setNumber("General.Terminal", 1)
    # SET ALGORITHM to Delaunay
    gmsh.option.setNumber(
        "Mesh.Algorithm3D", algorithm3D
    )  #  (1: Delaunay, 3: Initial mesh only, 4: Frontal, 7: MMG3D, 9: R-tree, 10: HXT)
    gmsh.option.setNumber(
        "Mesh.QualityType", 2
    )  # (0: SICN~signed inverse condition number, 1: SIGE~signed inverse gradient error, 2: gamma~vol/sum_face/max_edge, 3: Disto~minJ/maxJ)
    gmsh.option.setNumber("Mesh.Optimize", 1)
    # gmsh.option.setNumber("Mesh.AnisoMax", 1.0)
    # gmsh.option.setNumber("Mesh.OptimizeThreshold", 0.5)
    gmsh.option.setNumber(
        "Mesh.MeshSizeFactor", 1
    )  # always set to 1 (this nuber multiplies mesh sizes)

    # GENERATE VOLUME MESH
    n = gmsh.model.getDimension()
    s = gmsh.model.getEntities(n)
    l = gmsh.model.geo.addSurfaceLoop([s[i][1] for i in range(len(s))])
    gmsh.model.geo.addVolume([l])
    print("Volume added")
    gmsh.model.geo.synchronize()
    gmsh.model.mesh.generate(3)  # number of dimensions
    output_path, extension = os.path.splitext(
        output_path
    )  # it will get rid of the extension
    print(f"output path = {output_path}")
    gmsh.write(output_path + ".msh")
    # gmsh can save the output mesh as .msh but not as .xml :/

    # CONVERT TO DESIRED OUTPUT FORMAT - MESHIO
    mesh = meshio.read(output_path + ".msh")
    # meshio loads .msh and saves both .xml and .vtu meshes

    # write in xml and vtu formats
    meshio.write_points_cells(output_path + ".xml", mesh.points, mesh.cells)
    meshio.write_points_cells(output_path + ".vtu", mesh.points, mesh.cells)
    gmsh.finalize()


def volume_mesh_from_open_surface(
    surface_path: str,
    hmin: float = 1e-5,
    hmax: float = 5e-5,
    output_path: str = "cylinder.xml",
    uniform: bool = False,
    extend_field: bool = True,
    boundary_layer: bool = True,
    num_elems_layer: List[int] = [3, 1],
    height_layer: List[float] = [-2e-5, -3e-5],
):
    """
    Generates a volume mesh with tetrahedral boundary layers using GMSH.
    Input:
    - input_path : path to the stl mesh generated by create_surface_tube
    - hmin, hmax : characteristic edgelengths are the options for gmsh to generate volume mesh
    - output_path : path to a new volume mesh; possible extension of the file will be cut
                    and only .vtu and .xml files will be saved (it must be a file format that meshio can handle)
    - uniform : (Boolean) if True, the volume mesh will have the same edgelength as the surface mesh
    - extend_field : (Boolean) if True, the volume mesh will be finer near the boundary
                    and the element size will increase linearly with distance from the boundary;
                    if extend_field=True, the following options will be used:
                    - DistMax = 4*hmax (thickness of the extend field)
                    - SizeMax = hmax (maximum size of elements)
                    - Power = 1.0 (linear increase)
    - boundary_layer : (Boolean) if True, the following options must be specified:
        - num_elems_layer : (array) number of elements in the boundary layer with the same size
        - height_layer : (array) corresponding height of the boundary layer
                        the actual edgelength is height_layer/num_elem_layer
                        NOTE: the height must have a negative sign if we want to generate the boundary layer inside the cylinder

    Output:
    - volume mesh (specify the output_file)
    """

    folder = os.path.dirname(surface_path)  # get the name of the folder
    output_path, extension = os.path.splitext(
        output_path
    )  # it will get rid of the extension
    gmsh.initialize()
    gmsh.merge(surface_path)  # load surface mesh to gmsh

    # (1: Delaunay, 3: Initial mesh only, 4: Frontal, 7: MMG3D, 9: R-tree, 10: HXT)
    gmsh.option.setNumber("Mesh.Algorithm3D", 1)
    gmsh.option.setNumber("Mesh.Optimize", 1)
    gmsh.option.setNumber("Mesh.OptimizeThreshold", 0.6)

    gmsh.model.mesh.classifySurfaces(math.pi, True, True)
    gmsh.model.geo.synchronize()

    if boundary_layer:
        assert len(height_layer) == len(num_elems_layer)
        # make extrusions only return "top" surfaces and volumes, not lateral surfaces
        gmsh.option.setNumber("Geometry.ExtrudeReturnLateralEntities", 0)
        e = gmsh.model.geo.extrudeBoundaryLayer(
            gmsh.model.getEntities(2), num_elems_layer, height_layer, False
        )  # the last argument, recombine=False, says that we do not want prismatic elements but tetrahedral

        # get "top" surfaces created by extrusion
        top_ent = [s for s in e if s[0] == 2]
        top_surf = [s[1] for s in top_ent]

        # get boundary of top surfaces, i.e. boundaries of holes
        gmsh.model.geo.synchronize()
        bnd_ent = gmsh.model.getBoundary(top_ent)
        bnd_curv = [c[1] for c in bnd_ent]

        # create plane surfaces filling the holes
        loops = gmsh.model.geo.addCurveLoops(bnd_curv)
        for l in loops:
            top_surf.append(gmsh.model.geo.addPlaneSurface([l]))

        # # create the inner volume
        gmsh.model.geo.addVolume([gmsh.model.geo.addSurfaceLoop(top_surf)])
        gmsh.model.geo.synchronize()
    else:
        # CAP THE SURFACE MESH
        # get surface entities and tags
        s_ent = gmsh.model.getEntities(2)  # surface entities
        surf_tags = [s[1] for s in s_ent]

        # get boundaries of holes
        bnd_ent = gmsh.model.getBoundary(s_ent)
        curv_tags = [c[1] for c in bnd_ent]

        # create plane surfaces filling the holes
        loops = gmsh.model.geo.addCurveLoops(curv_tags)
        for l in loops:
            surf_tags.append(gmsh.model.geo.addPlaneSurface([l]))

        gmsh.model.geo.synchronize()
        gmsh.model.mesh.generate(3)

        # GENERATE VOLUME MESH
        n = gmsh.model.getDimension()
        s = gmsh.model.getEntities(n)
        l = gmsh.model.geo.addSurfaceLoop([s[i][1] for i in range(len(s))])
        gmsh.model.geo.addVolume([l])
        gmsh.model.geo.synchronize()

    if uniform:
        gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 1)
    elif not extend_field:
        gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
        gmsh.option.setNumber("Mesh.MeshSizeMax", hmax)
        gmsh.option.setNumber("Mesh.MeshSizeMin", hmin)
    else:
        gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
        gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
        gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)
        # source code: https://gitlab.onelab.info/gmsh/gmsh/-/blob/gmsh_4_11_1/examples/api/extend_field.py
        f = gmsh.model.mesh.field.add("Extend")
        gmsh.model.mesh.field.setNumbers(
            f, "SurfacesList", [e[1] for e in gmsh.model.getEntities(2)]
        )
        gmsh.model.mesh.field.setNumbers(
            f, "CurvesList", [e[1] for e in gmsh.model.getEntities(1)]
        )
        gmsh.model.mesh.field.setNumber(f, "DistMax", 4 * hmax)
        gmsh.model.mesh.field.setNumber(f, "SizeMax", hmax)
        gmsh.model.mesh.field.setNumber(f, "Power", 1.0)
        gmsh.model.mesh.field.setAsBackgroundMesh(f)

    # add physical groups (necessary for conversion to fenicsx)
    volumes = gmsh.model.getEntities(dim=3)
    if len(volumes) > 1:
        for j in range(len(volumes)):
            gmsh.model.addPhysicalGroup(volumes[j][0], [volumes[j][1]], j + 1)
    else:  # not tested yet
        gmsh.model.addPhysicalGroup(volumes[0][0], [volumes[0][1]], 1)
        gmsh.model.addPhysicalGroup(2, [2], 2)
    gmsh.model.mesh.generate(3)
    # Finalize the Gmsh session

    # gmsh can save the output mesh as .msh but not as .xml :/
    gmsh.write(output_path + ".msh")
    gmsh.finalize()

    # CONVERT TO DESIRED OUTPUT FORMAT - MESHIO
    # meshio loads .msh and saves both .xml and .vtu meshes
    mesh = meshio.read(output_path + ".msh")
    # write in xml and vtu formats
    meshio.write_points_cells(output_path + ".xml", mesh.points, mesh.cells)
    meshio.write_points_cells(output_path + ".vtu", mesh.points, mesh.cells)
